#!/usr/bin/env bash
#!/opt/homebrew/bin/bash

set -eEo pipefail


# shellcheck source=ci/docker_commands
source "${SCRIPTPATH}/docker_commands"

declare -A checksums

IMAGE_FLAVOR=${IMAGE_FLAVOR:-'ubuntu'}

#image_platform=""
#if [[ "${IMAGE_FLAVOR}" == ubuntu* ]]; then
#  image_platform="ubuntu"
#elif [[ "${IMAGE_FLAVOR}" == ubi-fips* ]]; then
#  image_platform="ubi-fips"
#else
#  image_platform="alpine"
#fi
#
#declare -A base_images_from_flavor
#base_images_from_flavor=(
#  ["ubuntu"]="ubuntu:${UBUNTU_VERSION}"
#  ["alpine3.12"]="alpine:${ALPINE_312_VERSION}"
#  ["alpine3.13"]="alpine:${ALPINE_313_VERSION}"
#  ["alpine3.14"]="alpine:${ALPINE_314_VERSION}"
#  ["alpine3.15"]="alpine:${ALPINE_315_VERSION}"
#  ["alpine-latest"]="alpine:latest"
#  ["ubi-fips"]="redhat/ubi8:${UBI_FIPS_VERSION}"
#)
#
#get_image_version_from_flavor() {
#  local flavor="$1"
#  echo "${base_images_from_flavor[${flavor}]}"
#}
#
## This marks the alpine3.15 to be aliased to alpine,
## which makes 3.15 the default alpine version for users
#declare -A flavor_aliases
#flavor_aliases=( ["alpine3.15"]="alpine,alpine3.15" )
#
#get_flavor_aliases() {
#  local flavor="$1"
#  if [[ "${flavor_aliases[$flavor]}" != "" ]]; then
#      echo "${flavor_aliases[$flavor]}"
#  else
#      echo "$flavor"
#  fi
#}
#
if [ -n "${TARGET_ARCHS}" ]; then
    IFS=' ' read -r -a TARGET_ARCHS <<< "${TARGET_ARCHS}"
else
    TARGET_ARCHS=('amd64')
fi
#
#if [[ "${PUSH_TO_ECR_PUBLIC}" == "true" ]] && [[ -n "${ECR_PUBLIC_USER}" ]]; then
#  ECR_PUBLIC_REGISTRY_PASSWORD=$(aws --region us-east-1 ecr-public get-login-password)
#fi
#
#join_by() {
#    local IFS="$1"
#    shift
#    echo "$*"
#}
#
## buildx receives an array of tag names, and the context path as the last parameter
#buildx() {
#    local contextPath="$1"
#    local base_image="$2"
#    local platforms=()
#    local os
#    os=$(_docker version -f '{{.Server.Os}}')
#    for arch in "${TARGET_ARCHS[@]}"; do
#        platforms+=("${os}/${arch}")
#    done
#
#    shift
#    shift
#
#    local args=("$@")
#    local buildxFlags=()
#
#    # Build -t tag name options from remaining arguments
#    local tagOpts=()
#    for tagName in "${args[@]}"; do
#        tagOpts+=("--tag" "${tagName}")
#    done
#
#    if [[ "${PUBLISH_IMAGES}" == "true" ]]; then
#        echo -e "\033[1mBuilding and pushing image: \033[32m${contextPath}\033[0m"
#        buildxFlags+=("--push")
#    else
#        # If not pushing, just load the resulting image to local Docker
#        if [ ${#TARGET_ARCHS[@]} -eq 1 ]; then
#            echo -e "\033[1mBuilding and loading image: \033[32m${contextPath}\033[0m"
#            # But that is only possible if we are targeting a single platform
#            buildxFlags+=("--load")
#        else
#            echo -e "\033[1mBuilding image: \033[32m${contextPath}\033[0m"
#        fi
#    fi
#
#    trap cleanup_docker_context_trap ERR SIGINT SIGTERM
#    setup_docker_context
#
#    if [[ "${PUBLISH_IMAGES}" == "true" ]] && [[ -n "${CI_REGISTRY_USER}" ]] && [[ -n "${CI_REGISTRY_PASSWORD}" ]]; then
#        login "${CI_REGISTRY_USER}" "${CI_REGISTRY_PASSWORD}" "${CI_REGISTRY}"
#    fi
#    if [[ "${PUSH_TO_DOCKER_HUB}" == "true" ]] && [[ -n "${DOCKER_HUB_USER}" ]] && [[ -n "${DOCKER_HUB_PASSWORD}" ]]; then
#        login "${DOCKER_HUB_USER}" "${DOCKER_HUB_PASSWORD}"
#    fi
#    if [[ "${PUSH_TO_ECR_PUBLIC}" == "true" ]] && [[ -n "${ECR_PUBLIC_USER}" ]] && [[ -n "${ECR_PUBLIC_REGISTRY_PASSWORD}" ]]; then
#        ECR_PUBLIC_REGISTRY_PASSWORD=$(aws --region us-east-1 ecr-public get-login-password)
#        login "${ECR_PUBLIC_USER}" "${ECR_PUBLIC_REGISTRY_PASSWORD}" "${ECR_PUBLIC_REGISTRY}"
#    fi
#
#    local formatted_platforms
#    formatted_platforms=$(join_by , "${platforms[@]}")
#    _docker_buildx build \
#        --build-arg DOCKER_MACHINE_VERSION="${DOCKER_MACHINE_VERSION}" \
#        --build-arg DUMB_INIT_VERSION="${DUMB_INIT_VERSION}" \
#        --build-arg GIT_LFS_VERSION="${GIT_LFS_VERSION}" \
#        --build-arg BASE_IMAGE="${base_image}" \
#        --platform "${formatted_platforms}" \
#        --no-cache \
#        "${tagOpts[@]}" \
#        "${buildxFlags[@]}" \
#        "${contextPath}"
#    trap - ERR SIGINT SIGTERM
#    cleanup_docker_context
#
#    if [[ -z "${PUBLISH_IMAGES}" ]] || [[ "${PUBLISH_IMAGES}" != "true" ]]; then
#        echo "Skipping images pushing"
#    fi
#
#    if [[ "${PUBLISH_IMAGES}" == "true" ]] && [[ -n "${CI_REGISTRY_USER}" ]] && [[ -n "${CI_REGISTRY_PASSWORD}" ]]; then
#        logout "${CI_REGISTRY}"
#    fi
#    if [[ "${PUSH_TO_DOCKER_HUB}" == "true" ]] && [[ -n "${DOCKER_HUB_USER}" ]] && [[ -n "${DOCKER_HUB_PASSWORD}" ]]; then
#        logout
#    fi
#    if [[ "${PUSH_TO_ECR_PUBLIC}" == "true" ]] && [[ -n "${ECR_PUBLIC_USER}" ]] && [[ -n "${ECR_PUBLIC_REGISTRY_PASSWORD}" ]]; then
#        logout "${ECR_PUBLIC_REGISTRY}"
#    fi
#}
#
#add_tags() {
#    local -n add_to_tags=$1
#    local base_images="$2"
#    local user="$3"
#    local password="$4"
#    local repository="$5"
#    local default_image='ubuntu'
#
#    if [[ -z "${user}" ]] || [[ -z "${password}" ]]; then
#        return
#    fi
#
#    for base_image in ${base_images//,/ }; do
#      add_to_tags+=("${repository}:${base_image}-${ref_tag}")
#      if [[ "${base_image}" == "${default_image}" ]]; then
#          add_to_tags+=("${repository}:${ref_tag}")
#      fi
#      if [[ -n "${IS_LATEST}" ]]; then
#          add_to_tags+=("${repository}:${base_image}")
#          if [[ "${base_image}" == "${default_image}" ]]; then
#              add_to_tags+=("${repository}:latest")
#          fi
#      fi
#    done
#}
#
#[ "${#TARGET_ARCHS[@]}" -eq 0 ] && TARGET_ARCHS=("$(_docker version -f '{{.Server.Arch}}')")
#
#runner_home_dir="dockerfiles/runner"
#
#function writeChecksum() {
#  local binVarNamePrefix="$1"
#  local targetArch="$2"
#  local binFile="$3"
#  local archVarNameSuffix=$(echo "${targetArch}" | tr '[:lower:]' '[:upper:]')
#  local checksum="${checksums["${binVarNamePrefix}_${archVarNameSuffix}"]}"
#
#  [[ -n "${checksum}" ]] && echo "${checksum}  ${binFile}" >> "${runner_home_dir}/checksums-${targetArch}" || return 0
#}
#
#for arch in "${TARGET_ARCHS[@]}"; do
#    echo "${arch}:"
#    rm -f "${runner_home_dir}/checksums-${arch}"
#    writeChecksum 'DOCKER_MACHINE' "${arch}" '/usr/bin/docker-machine'
#    writeChecksum 'DUMB_INIT' "${arch}" '/usr/bin/dumb-init'
#    writeChecksum 'GIT_LFS' "${arch}" '/tmp/git-lfs.tar.gz'
#done
#
#cp "${runner_home_dir}/install-deps" "${runner_home_dir}/ubuntu/"
#cp "${runner_home_dir}/install-deps" "${runner_home_dir}/alpine/"
#cp "${runner_home_dir}/install-deps" "${runner_home_dir}/ubi-fips/"
#for arch in "${TARGET_ARCHS[@]}"; do
#    deb_arch=$(if [ "${arch}" == "ppc64le" ]; then echo "ppc64el"; else echo "${arch}"; fi)
#    cp "${runner_home_dir}/checksums-${arch}" "out/deb/gitlab-runner_${deb_arch}.deb" \
#        "${runner_home_dir}/ubuntu/"
#    cp "${runner_home_dir}/checksums-${arch}" "out/binaries/gitlab-runner-linux-${arch}" \
#        "${runner_home_dir}/alpine/"
#    if [[ $arch == "amd64" ]]; then
#        cp "${runner_home_dir}/checksums-${arch}" \
#           "out/binaries/gitlab-runner-linux-${arch}-fips" \
#           "out/rpm/gitlab-runner_${arch}-fips.rpm" \
#           "${runner_home_dir}/ubi-fips/"
#    fi
#done
#
#tags=()
#aliases="$(get_flavor_aliases "$IMAGE_FLAVOR")"
#
#if [[ "${PUBLISH_IMAGES}" == "true" ]] && [[ -n "${CI_REGISTRY}" ]] && [[ -n "${CI_REGISTRY_IMAGE}" ]]; then
#   add_tags tags "${aliases}" "${CI_REGISTRY_USER}" "${CI_REGISTRY_PASSWORD}" "${CI_REGISTRY_IMAGE}" "${ref_tag}"
#fi
#
#if [[ "${PUBLISH_IMAGES}" == "true" ]] && [[ "${PUSH_TO_DOCKER_HUB}" == "true" ]]; then
#   add_tags tags "${aliases}" "${DOCKER_HUB_USER}" "${DOCKER_HUB_PASSWORD}" "${DOCKER_HUB_NAMESPACE}/gitlab-runner" "${ref_tag}"
#fi
#
#if [[ "${PUBLISH_IMAGES}" == "true" ]] && [[ "${PUSH_TO_ECR_PUBLIC}" == "true" ]]; then
#   add_tags tags "${aliases}" "${ECR_PUBLIC_USER}" "${ECR_PUBLIC_REGISTRY_PASSWORD}" "${ECR_PUBLIC_REGISTRY}/gitlab-runner" "${ref_tag}"
#fi
#
## Build and publish multi-platform images using `docker buildx`
## shellcheck disable=SC2154
#base_image="$(get_image_version_from_flavor "${IMAGE_FLAVOR}")"
#
## Workaround for linux/s390x building problem when Go>=1.5 is used
#buildx_call_failed="false"
#ALLOW_IMAGE_BUILD_FAILURE=${ALLOW_IMAGE_BUILD_FAILURE:-"false"}
#
#buildx "${runner_home_dir}/${image_platform}" "$base_image" "${tags[@]}" || buildx_call_failed="true"
#
#if [[ "${buildx_call_failed}" == "true" ]]; then
#  echo -e "\033[2mImage build with buildx have failed!\033[0m"
#  if [[ "${ALLOW_IMAGE_BUILD_FAILURE}" == "true" ]]; then
#    echo "Ignoring the failure as ALLOW_IMAGE_BUILD_FAILURE is set to true"
#    exit 0
#  else
#    exit 1
#  fi
#fi
