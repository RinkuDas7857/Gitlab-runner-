#!/usr/bin/env bash

set -eEo pipefail

SCRIPTPATH="$( cd "$(dirname "$0")" ; pwd -P )"

# shellcheck source=ci/docker_buildx_commands
source "${SCRIPTPATH}/docker_buildx_commands"

declare -A checksums

DOCKER_MACHINE_VERSION=${DOCKER_MACHINE_VERSION:-0.16.2}
checksums['DOCKER_MACHINE_AMD64']=${DOCKER_MACHINE_LINUX_AMD64_CHECKSUM:-a7f7cbb842752b12123c5a5447d8039bf8dccf62ec2328853583e68eb4ffb097}
checksums['DOCKER_MACHINE_ARM64']=${DOCKER_MACHINE_LINUX_ARM64_CHECKSUM:-109f534bfb8b9b852c938cad978e60a86b13f5ecf92da5e24320dacd2a7216ac}
checksums['DOCKER_MACHINE_S390X']="" # No binary available yet for s390x, see https://gitlab.com/gitlab-org/gitlab-runner/-/issues/26551
DUMB_INIT_VERSION=${DUMB_INIT_VERSION:-1.2.2}
checksums['DUMB_INIT_AMD64']=${DUMB_INIT_LINUX_AMD64_CHECKSUM:-37f2c1f0372a45554f1b89924fbb134fc24c3756efaedf11e07f599494e0eff9}
checksums['DUMB_INIT_ARM64']=${DUMB_INIT_LINUX_ARM64_CHECKSUM:-45b1bbf56cc03edda81e4220535a025bfe3ed6e93562222b9be4471005b3eeb3}
checksums['DUMB_INIT_S390X']=${DUMB_INIT_LINUX_S390X_CHECKSUM:-8b3808c3c06d008b8f2eeb2789c7c99e0450b678d94fb50fd446b8f6a22e3a9d}
GIT_LFS_VERSION=${GIT_LFS_VERSION:-2.11.0}
checksums['GIT_LFS_AMD64']=${GIT_LFS_LINUX_AMD64_CHECKSUM:-46508eb932c2ec0003a940f179246708d4ddc2fec439dcacbf20ff9e98b957c9}
checksums['GIT_LFS_ARM64']=${GIT_LFS_LINUX_ARM64_CHECKSUM:-ba6a2820d6afcdf94a83c9307bfbabcc2f8146b27404b450c673567798a81f67}
checksums['GIT_LFS_S390X']=${GIT_LFS_LINUX_S390X_CHECKSUM:-ca73776cb1cdc855aaf743c09ae70caae97f67d8d5e4147f19dcc4f959f9fc4d}

if [ -n "${TARGET_ARCHS}" ]; then
    IFS=', ' read -r -a TARGET_ARCHS <<< "${TARGET_ARCHS}"
else
    TARGET_ARCHS=('amd64')
fi

CI_COMMIT_TAG=${CI_COMMIT_TAG:-}
CI_REGISTRY=${CI_REGISTRY:-}
CI_REGISTRY_IMAGE=${CI_REGISTRY_IMAGE:-}
CI_REGISTRY_USER=${CI_REGISTRY_USER:-}
CI_REGISTRY_PASSWORD=${CI_REGISTRY_PASSWORD:-}
PUBLISH_IMAGES=${PUBLISH_IMAGES:-false}

ref_tag="${CI_COMMIT_TAG}"
if [[ -z "${ref_tag}" ]]; then
    ref_tag=${CI_COMMIT_REF_SLUG:-main}
fi

if [[ "${ref_tag}" == "main" ]]; then
    ref_tag=bleeding
fi

REVISION=${REVISION:-}
if [[ -z "${REVISION}" ]]; then
    REVISION=$(git rev-parse --short=8 HEAD || echo "unknown")
fi

join_by() {
    local IFS="$1"
    shift
    echo "$*"
}

# buildx receives an array of tag names, and the context path as the last parameter
buildx() {
    local flavor="$2"
    local contextPath="$1/$flavor"
    local platforms=()
    local os
    os=$(_docker version -f '{{.Server.Os}}')
    for arch in "${TARGET_ARCHS[@]}"; do
        platforms+=("${os}/${arch}")
    done
    shift

    trap cleanup_docker_context_trap ERR SIGINT SIGTERM
    setup_docker_context

    local formatted_platforms
    formatted_platforms=$(join_by , "${platforms[@]}")
    _docker_buildx build \
        --build-arg DOCKER_MACHINE_VERSION="${DOCKER_MACHINE_VERSION}" \
        --build-arg DUMB_INIT_VERSION="${DUMB_INIT_VERSION}" \
        --build-arg GIT_LFS_VERSION="${GIT_LFS_VERSION}" \
        --platform "${formatted_platforms}" \
        --no-cache \
        --output "type=tar,dest=out/runner-images/gitlab-runner-$flavor" \
        "${contextPath}"
    trap - ERR SIGINT SIGTERM
    cleanup_docker_context
}

tag() {
    echo -e "\033[1mTagging image: \033[32m${2}\033[0m"
    _docker tag "${1}" "${2}"
}

tag_latest() {
    if [[ -z "${IS_LATEST}" ]]; then
        return
    fi

    tag "${@}"
}

add_tags() {
    local -n tags=$1
    local base_image="$2"
    local user="$3"
    local password="$4"
    local repository="$5"
    local default_image='ubuntu'

    if [[ -z "${user}" ]] || [[ -z "${password}" ]]; then
        return
    fi

    tags+=("${repository}:${base_image}-${ref_tag}")
    if [[ "${base_image}" == "${default_image}" ]]; then
        tags+=("${repository}:${ref_tag}")
    fi
    if [[ -n "${IS_LATEST}" ]]; then
        tags+=("${repository}:${base_image}")
        if [[ "${base_image}" == "${default_image}" ]]; then
            tags+=("${repository}:latest")
        fi
    fi
}

[ "${#TARGET_ARCHS[@]}" -eq 0 ] && TARGET_ARCHS=("$(_docker version -f '{{.Server.Arch}}')")

runner_home_dir="dockerfiles/runner"

function writeChecksum() {
  local binVarNamePrefix="$1"
  local targetArch="$2"
  local binFile="$3"
  local archVarNameSuffix=$(echo "${targetArch}" | tr '[:lower:]' '[:upper:]')
  local checksum="${checksums["${binVarNamePrefix}_${archVarNameSuffix}"]}"

  [[ -n "${checksum}" ]] && echo "${checksum}  ${binFile}" >> "${runner_home_dir}/checksums-${targetArch}" || return 0
}

for arch in "${TARGET_ARCHS[@]}"; do
    echo "${arch}:"
    rm -f "${runner_home_dir}/checksums-${arch}"
    writeChecksum 'DOCKER_MACHINE' "${arch}" '/usr/bin/docker-machine'
    writeChecksum 'DUMB_INIT' "${arch}" '/usr/bin/dumb-init'
    writeChecksum 'GIT_LFS' "${arch}" '/tmp/git-lfs.tar.gz'
done

cp "${runner_home_dir}/install-deps" "${runner_home_dir}/ubuntu/"
cp "${runner_home_dir}/install-deps" "${runner_home_dir}/alpine/"
for arch in "${TARGET_ARCHS[@]}"; do
    cp "${runner_home_dir}/checksums-${arch}" "out/deb/gitlab-runner_${arch}.deb" \
        "${runner_home_dir}/ubuntu/"
    cp "${runner_home_dir}/checksums-${arch}" "out/binaries/gitlab-runner-linux-${arch}" \
        "${runner_home_dir}/alpine/"
done

mkdir -p out/runner-images

# Build and publish multi-platform images using `docker buildx`
buildx "${runner_home_dir}" "ubuntu"
buildx "${runner_home_dir}" "alpine"
